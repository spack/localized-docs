# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-03-17 09:38+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/build_systems.rst:22
#: ../spack/lib/spack/docs/build_systems.rst:22
msgid "Make-based"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:28
#: ../spack/lib/spack/docs/build_systems.rst:28
msgid "Make-incompatible"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:35
#: ../spack/lib/spack/docs/build_systems.rst:35
msgid "Build-script generation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:44
#: ../spack/lib/spack/docs/build_systems.rst:44
msgid "Language-specific"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:54
#: ../spack/lib/spack/docs/build_systems.rst:54
msgid "Other"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:11
msgid "Build Systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:13
msgid "Spack defines a number of classes which understand how to use common `build systems  <https://en.wikipedia.org/wiki/List_of_build_automation_software>`_ (Makefiles, CMake, etc.). Spack package definitions can inherit these classes in order to streamline their builds."
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:18
msgid "This guide provides information specific to each particular build system. It assumes that you've read the :ref:`packaging-guide` and expands on these ideas for each distinct build system that Spack supports:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:62
msgid "For reference, the :py:mod:`Build System API docs <spack.build_systems>` provide a list of build systems and methods/attributes that can be overridden. If you are curious about the implementation of a particular build system, you can view the source code by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:72
msgid "This will open up the ``AutotoolsPackage`` definition in your favorite editor. In addition, if you are working with a less common build system like QMake, SCons, or Waf, it may be useful to see examples of other packages. You can quickly find examples by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:83
msgid "You can then view these packages with ``spack edit``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:85
msgid "This guide is intended to supplement the :py:mod:`Build System API docs <spack.build_systems>` with examples of how to override commonly used methods. It also provides rules of thumb and suggestions for package developers who are unfamiliar with a particular build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:10
msgid "AutotoolsPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:12
msgid "Autotools is a GNU build system that provides a build-script generator. By running the platform-independent ``./configure`` script that comes with the package, you can generate a platform-dependent Makefile."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:18
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:22
#: ../spack/lib/spack/docs/build_systems/custompackage.rst:48
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:19
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:18
#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:16
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:17
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:16
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:30
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:20
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:34
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:17
msgid "Phases"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:20
msgid "The ``AutotoolsPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:22
msgid "``autoreconf`` - generate the configure script"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:23
msgid "``configure`` - generate the Makefiles"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:24
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:27
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:22
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:48
msgid "``build`` - build the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:25
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:28
#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:20
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:23
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:24
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:49
msgid "``install`` - install the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:27
msgid "Most of the time, the ``autoreconf`` phase will do nothing, but if the package is missing a ``configure`` script, ``autoreconf`` will generate one for you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:31
msgid "The other phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:42
msgid "Of course, you may need to add a few arguments to the ``./configure`` line."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:47
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:48
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:39
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:51
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:86
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:60
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:65
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:74
msgid "Important files"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:49
msgid "The most important file for an Autotools-based package is the ``configure`` script. This script is automatically generated by Autotools and generates the appropriate Makefile when run."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:55
msgid "Watch out for fake Autotools packages!"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:57
msgid "Autotools is a very popular build system, and many people are used to the classic steps to install a package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:67
msgid "For this reason, some developers will write their own ``configure`` scripts that have nothing to do with Autotools. These packages may not accept the same flags as other Autotools packages, so it is better to use the ``Package`` base class and create a :ref:`custom build system <custompackage>`. You can tell if a package uses Autotools by running ``./configure --help`` and comparing the output to other known Autotools packages. You should also look for files like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:75
msgid "``configure.ac``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:76
msgid "``configure.in``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:77
msgid "``Makefile.am``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:79
msgid "Packages that don't use Autotools aren't likely to have these files."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:83
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:77
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:53
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:81
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:114
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:248
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:78
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:125
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:83
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:88
msgid "Build system dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:85
msgid "Whether or not your package requires Autotools to install depends on how the source code is distributed. Most of the time, when developers distribute tarballs, they will already contain the ``configure`` script necessary for installation. If this is the case, your package does not require any Autotools dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:91
msgid "However, a basic rule of version control systems is to never commit code that can be generated. The source code repository itself likely does not have a ``configure`` script. Developers typically write (or auto-generate) a ``configure.ac`` script that contains configuration preferences and a ``Makefile.am`` script that contains build instructions. Then, ``autoconf`` is used to convert ``configure.ac`` into ``configure``, while ``automake`` is used to convert ``Makefile.am`` into ``Makefile.in``. ``Makefile.in`` is used by ``configure`` to generate a platform-dependent ``Makefile`` for you. The following diagram provides a high-level overview of the process:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:105
msgid "`GNU autoconf and automake process for generating makefiles <https://commons.wikimedia.org/wiki/File:Autoconf-automake-process.svg>`_ by `Jdthood` under `CC BY-SA 3.0 <https://creativecommons.org/licenses/by-sa/3.0/deed.en>`_"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:108
msgid "If a ``configure`` script is not present in your tarball, you will need to generate one yourself. Luckily, Spack already has an ``autoreconf`` phase to do most of the work for you. By default, the ``autoreconf`` phase runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:119
msgid "All you need to do is add a few Autotools dependencies to the package. Most stable releases will come with a ``configure`` script, but if you check out a commit from the ``develop`` branch, you would want to add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:130
msgid "In some cases, developers might need to distribute a patch that modifies one of the files used to generate ``configure`` or ``Makefile.in``. In this case, these scripts will need to be regenerated. It is preferable to regenerate these manually using the patch, and then create a new patch that directly modifies ``configure``. That way, Spack can use the secondary patch and additional build system dependencies aren't necessary."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:140
msgid "force_autoreconf"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:142
msgid "If for whatever reason you really want to add the original patch and tell Spack to regenerate ``configure``, you can do so using the following setting:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:150
msgid "This line tells Spack to wipe away the existing ``configure`` script and generate a new one. If you only need to do this for a single version, this can be done like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:162
msgid "Finding configure flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:164
msgid "Once you have a ``configure`` script present, the next step is to determine what option flags are available. These flags can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:172
msgid "``configure`` will display a list of valid flags separated into some or all of the following sections:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:175
msgid "Configuration"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:176
msgid "Installation directories"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:177
msgid "Fine tuning of the installation directories"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:178
msgid "Program names"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:179
msgid "X features"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:180
msgid "System types"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:181
msgid "**Optional Features**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:182
msgid "**Optional Packages**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:183
msgid "**Some influential environment variables**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:185
msgid "For the most part, you can ignore all but the last 3 sections. The \"Optional Features\" sections lists flags that enable/disable features you may be interested in. The \"Optional Packages\" section often lists dependencies and the flags needed to locate them. The \"environment variables\" section lists environment variables that the build system uses to pass flags to the compiler and linker."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:194
msgid "Addings flags to configure"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:196
msgid "For most of the flags you encounter, you will want a variant to optionally enable/disable them. You can then optionally pass these flags to the ``configure`` call by overriding the ``configure_args`` function like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:213
msgid "Note that we are explicitly disabling MPI support if it is not requested. This is important, as many Autotools packages will enable options by default if the dependencies are found, and disable them otherwise. We want Spack installations to be as deterministic as possible. If two users install a package with the same variants, the goal is that both installations work the same way. See `here <https://www.linux.com/news/best-practices-autotools>`__ and `here <https://wiki.gentoo.org/wiki/Project:Quality_Assurance/Automagic_dependencies>`__ for a rationale as to why these so-called \"automagic\" dependencies are a problem."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:223
msgid "By default, Autotools installs packages to ``/usr``. We don't want this, so Spack automatically adds ``--prefix=/path/to/installation/prefix`` to your list of ``configure_args``. You don't need to add this yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:229
msgid "Helper functions"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:231
msgid "You may have noticed that most of the Autotools flags are of the form ``--enable-foo``, ``--disable-bar``, ``--with-baz=<prefix>``, or ``--without-baz``. Since these flags are so common, Spack provides a couple of helper functions to make your life easier."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:236
msgid "TODO: document ``with_or_without`` and ``enable_or_disable``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:240
msgid "Configure script in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:242
msgid "Occasionally, developers will hide their source code and ``configure`` script in a subdirectory like ``src``. If this happens, Spack won't be able to automatically detect the build system properly when running ``spack create``. You will have to manually change the package base class and tell Spack where the ``configure`` script resides. You can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:255
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:233
msgid "Building out of source"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:257
msgid "Some packages like ``gcc`` recommend building their software in a different directory than the source code to prevent build pollution. This can be done using the ``build_directory`` variable:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:265
msgid "By default, Spack will build the package in the same directory that contains the ``configure`` script"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:270
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:245
msgid "Build and install targets"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:272
msgid "For most Autotools packages, the usual:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:280
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:255
msgid "is sufficient to install the package. However, if you need to run make with any other targets, for example, to build an optional library or build the documentation, you can add these like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:291
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:266
#: ../spack/lib/spack/docs/build_systems/custompackage.rst:169
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:518
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:55
msgid "Testing"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:293
msgid "Autotools-based packages typically provide unit testing via the ``check`` and ``installcheck`` targets. If you build your software with ``spack install --test=root``, Spack will check for the presence of a ``check`` or ``test`` target in the Makefile and run ``make check`` for you. After installation, it will check for an ``installcheck`` target and run ``make installcheck`` if it finds one."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:302
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:276
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:306
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:131
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:206
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:744
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:113
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:343
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:303
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:126
msgid "External documentation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:304
msgid "For more information on the Autotools build system, see: https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:10
msgid "CMakePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:12
msgid "Like Autotools, CMake is a widely-used build-script generator. Designed by Kitware, CMake is the most popular build system for new C, C++, and Fortran projects, and many older projects are switching to it as well."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:16
msgid "Unlike Autotools, CMake can generate build scripts for builders other than Make: Ninja, Visual Studio, etc. It is therefore cross-platform, whereas Autotools is Unix-only."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:24
msgid "The ``CMakePackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:26
msgid "``cmake`` - generate the Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:30
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:26
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:38
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:25
msgid "By default, these phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:42
msgid "A few more flags are passed to ``cmake`` by default, including flags for setting the build type and flags for locating dependencies. Of course, you may need to add a few arguments yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:50
msgid "A CMake-based package can be identified by the presence of a ``CMakeLists.txt`` file. This file defines the build flags that can be passed to the cmake invocation, as well as linking instructions. If you are familiar with CMake, it can prove very useful for determining dependencies and dependency version requirements."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:56
msgid "One thing to look for is the ``cmake_minimum_required`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:63
msgid "This means that CMake 2.8.12 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:66
msgid "CMake-based packages may also contain ``CMakeLists.txt`` in subdirectories. This modularization helps to manage complex builds in a hierarchical fashion. Sometimes these nested ``CMakeLists.txt`` require additional dependencies not mentioned in the top-level file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:71
msgid "There's also usually a ``cmake`` or ``CMake`` directory containing additional macros, find scripts, etc. These may prove useful in determining dependency version requirements."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:79
msgid "Every package that uses the CMake build system requires a ``cmake`` dependency. Since this is always the case, the ``CMakePackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:88
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:93
msgid "If you need to specify a particular version requirement, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:98
msgid "Finding cmake flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:100
msgid "To get a list of valid flags that can be passed to ``cmake``, run the following command in the directory that contains ``CMakeLists.txt``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:108
msgid "CMake will start by checking for compilers and dependencies. Eventually it will begin to list build options. You'll notice that most of the build options at the top are prefixed with ``CMAKE_``. You can safely ignore most of these options as Spack already sets them for you. This includes flags needed to locate dependencies, RPATH libraries, set the installation directory, and set the build type."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:115
msgid "The rest of the flags are the ones you should consider adding to your package. They often include flags to enable/disable support for certain features and locate specific dependencies. One thing you'll notice that makes CMake different from Autotools is that CMake has an understanding of build flag hierarchy. That is, certain flags will not display unless their parent flag has been selected. For example, flags to specify the ``lib`` and ``include`` directories for a package might not appear unless CMake found the dependency it was looking for. You may need to manually specify certain flags to explore the full depth of supported build flags, or check the ``CMakeLists.txt`` yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:128
msgid "Adding flags to cmake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:130
msgid "To add additional flags to the ``cmake`` call, simply override the ``cmake_args`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:148
msgid "Generators"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:150
msgid "CMake and Autotools are build-script generation tools; they \"generate\" the Makefiles that are used to build a software package. CMake actually supports multiple generators, not just Makefiles. Another common generator is Ninja. To switch to the Ninja generator, simply add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:160
msgid "``CMakePackage`` defaults to \"Unix Makefiles\". If you switch to the Ninja generator, make sure to add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:167
msgid "to the package as well. Aside from that, you shouldn't need to do anything else. Spack will automatically detect that you are using Ninja and run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:177
msgid "Spack currently only supports \"Unix Makefiles\" and \"Ninja\" as valid generators, but it should be simple to add support for alternative generators. For more information on CMake generators, see: https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:184
msgid "CMAKE_BUILD_TYPE"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:186
msgid "Every CMake-based package accepts a ``-DCMAKE_BUILD_TYPE`` flag to dictate which level of optimization to use. In order to ensure uniformity across packages, the ``CMakePackage`` base class adds a variant to control this:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:197
msgid "However, not every CMake package accepts all four of these options. Grep the ``CMakeLists.txt`` file to see if the default values are missing or replaced. For example, the `dealii <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/dealii/package.py>`_ package overrides the default variant with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:209
msgid "For more information on ``CMAKE_BUILD_TYPE``, see: https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:214
msgid "CMakeLists.txt in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:216
msgid "Occasionally, developers will hide their source code and ``CMakeLists.txt`` in a subdirectory like ``src``. If this happens, Spack won't be able to automatically detect the build system properly when running ``spack create``. You will have to manually change the package base class and tell Spack where ``CMakeLists.txt`` resides. You can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:228
msgid "Note that this path is relative to the root of the extracted tarball, not to the ``build_directory``. It defaults to the current directory."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:235
msgid "By default, Spack builds every ``CMakePackage`` in a ``spack-build`` sub-directory. If, for whatever reason, you would like to build in a different sub-directory, simply override ``build_directory`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:247
msgid "For most CMake packages, the usual:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:268
msgid "CMake-based packages typically provide unit testing via the ``test`` target. If you build your software with ``--test=root``, Spack will check for the presence of a ``test`` target in the Makefile and run ``make test`` for you. If you want to run a different test instead, simply override the ``check`` method."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:278
msgid "For more information on the CMake build system, see: https://cmake.org/cmake/help/latest/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:10
msgid "CudaPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:12
msgid "Different from other packages, ``CudaPackage`` does not represent a build system. Instead its goal is to simplify and unify usage of ``CUDA`` in other packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:18
msgid "Provided variants and dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:20
msgid "``CudaPackage`` provides ``cuda`` variant (default to ``off``) to enable/disable ``CUDA``, and ``cuda_arch`` variant to optionally specify the architecture. It also declares dependencies on the ``CUDA`` package ``depends_on('cuda@...')`` based on the architecture as well as specifies conflicts for certain compiler versions."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:27
msgid "Usage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:29
msgid "In order to use it, just add another base class to your package, for example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:10
msgid "Custom Build Systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:12
msgid "While the build systems listed above should meet your needs for the vast majority of packages, some packages provide custom build scripts. This guide is intended for the following use cases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:16
msgid "Packaging software with its own custom build system"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:17
msgid "Adding support for new build systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:19
msgid "If you want to add support for a new build system, a good place to start is to look at the definitions of other build systems. This guide focuses mostly on how Spack's build systems work."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:23
msgid "In this guide, we will be using the `perl <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/perl/package.py>`_ and `cmake <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cmake/package.py>`_ packages as examples. ``perl``'s build system is a hand-written ``Configure`` shell script, while ``cmake`` bootstraps itself during installation. Both of these packages require custom build systems."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:32
msgid "Base class"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:34
msgid "If your package does not belong to any of the aforementioned build systems that Spack already supports, you should inherit from the ``Package`` base class. ``Package`` is a simple base class with a single phase: ``install``. If your package is simple, you may be able to simply write an ``install`` method that gets the job done. However, if your package is more complex and installation involves multiple steps, you should add separate phases as mentioned in the next section."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:42
msgid "If you are creating a new build system base class, you should inherit from ``PackageBase``. This is the superclass for all build systems in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:50
msgid "The most important concept in Spack's build system support is the idea of phases. Each build system defines a set of phases that are necessary to install the package. They usually follow some sort of \"configure\", \"build\", \"install\" guideline, but any of those phases may be missing or combined with another phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:56
msgid "If you look at the ``perl`` package, you'll see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:62
msgid "Similarly, ``cmake`` defines:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:68
msgid "If we look at the ``cmake`` example, this tells Spack's ``PackageBase`` class to run the ``bootstrap``, ``build``, and ``install`` functions in that order. It is now up to you to define these methods."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:74
msgid "Phase and phase_args functions"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:76
msgid "If we look at ``perl``, we see that it defines a ``configure`` method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:84
msgid "There is also a corresponding ``configure_args`` function that handles all of the arguments to pass to ``Configure``, just like in ``AutotoolsPackage``. Comparatively, the ``build`` and ``install`` phases are pretty simple:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:97
msgid "The ``cmake`` package looks very similar, but with a ``bootstrap`` function instead of ``configure``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:112
msgid "Again, there is a ``boostrap_args`` function that determines the correct bootstrap flags to use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:117
msgid "run_before/run_after"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:119
msgid "Occasionally, you may want to run extra steps either before or after a given phase. This applies not just to custom build systems, but to existing build systems as well. You may need to patch a file that is generated by configure, or install extra files in addition to what ``make install`` copies to the installation prefix. This is where ``@run_before`` and ``@run_after`` come in."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:126
msgid "These Python decorators allow you to write functions that are called before or after a particular phase. For example, in ``perl``, we see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:142
msgid "This extra step automatically installs ``cpanm`` in addition to the base Perl installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:147
msgid "on_package_attributes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:149
msgid "The ``run_before``/``run_after`` logic discussed above becomes particularly powerful when combined with the ``@on_package_attributes`` decorator. This decorator allows you to conditionally run certain functions depending on the attributes of that package. The most common example is conditional testing. Many unit tests are prone to failure, even when there is nothing wrong with the installation. Unfortunately, non-portable unit tests and tests that are \"supposed to fail\" are more common than we would like. Instead of always running unit tests on installation, Spack lets users conditionally run tests with the ``--test=root`` flag."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:160
msgid "If we wanted to define a function that would conditionally run if and only if this flag is set, we would use the following line:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:171
msgid "Let's put everything together and add unit tests to our package. In the ``perl`` package, we can see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:181
msgid "As you can guess, this runs ``make test`` *after* building the package, if and only if testing is requested. Again, this is not specific to custom build systems, it can be added to existing build systems as well."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:185
msgid "Ideally, every package in Spack will have some sort of test to ensure that it was built correctly. It is up to the package authors to make sure this happens. If you are adding a package for some software and the developers list commands to test the installation, please add these tests to your ``package.py``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:193
msgid "The order of decorators matters. The following ordering:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:200
msgid "works as expected. However, if you reverse the ordering:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:207
msgid "the tests will always be run regardless of whether or not ``--test=root`` is requested. See https://github.com/spack/spack/issues/3833 for more information"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:10
msgid "IntelPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:12
msgid "Contents"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:16
msgid "Intel packages in Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:18
msgid "Spack can install and use several software development products offered by Intel. Some of these are available under no-cost terms, others require a paid license. All share the same basic steps for configuration, installation, and, where applicable, license management. The Spack Python class ``IntelPackage`` implements these steps."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:24
msgid "Spack interacts with Intel tools in several routes, like it does for any other package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:29
msgid "Accept system-provided tools after you declare them to Spack as *external packages*."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:33
msgid "Install the products for you as *internal packages* in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:37
msgid "*Use* the packages, regardless of installation route, to install what we'll call *client packages* for you, this being Spack's primary purpose."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:40
msgid "An auxiliary route follows from route 2, as it would for most Spack packages, namely:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:45
msgid "Make Spack-installed Intel tools available outside of Spack for ad-hoc use, typically through Spack-managed modulefiles."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:48
msgid "This document covers routes 1 through 3."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:53
msgid "Packages under no-cost license"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:55
msgid "Intel's standalone performance library products, notably MKL and MPI, are available for use under a `simplified license <https://software.intel.com/en-us/license/intel-simplified-software-license>`_ since 2017 [fn1]_. They are packaged in Spack as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:60
msgid "``intel-mkl`` -- Math Kernel Library (linear algebra and FFT),"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:61
msgid "``intel-mpi`` -- The Intel-MPI implementation (derived from MPICH),"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:62
msgid "``intel-ipp`` -- Primitives for image-, signal-, and data-processing,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:63
msgid "``intel-daal`` -- Machine learning and data analytics."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:65
msgid "Some earlier versions of these libraries were released under a paid license. For these older versions, the license must be available at installation time of the products and during compilation of client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:69
msgid "The library packages work well with the Intel compilers but do not require them -- those packages can just as well be used with other compilers.  The Intel compiler invocation commands offer custom options to simplify linking Intel libraries (sometimes considerably), but Spack always uses fairly explicit linkage anyway."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:78
msgid "Licensed packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:80
msgid "Intel's core software development products that provide compilers, analyzers, and optimizers do require a paid license.  In Spack, they are packaged as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:83
msgid "``intel-parallel-studio`` -- the entire suite of compilers and libraries,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:84
msgid "``intel`` -- a subset containing just the compilers and the Intel-MPI runtime [fn2]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:97
msgid "The license is needed at installation time and to compile client packages, but never to merely run any resulting binaries. The license status for a given Spack package is normally specified in the *package code* through directives like `license_required` (see :ref:`Licensed software <license>`). For the Intel packages, however, the *class code* provides these directives (in exchange of forfeiting a measure of OOP purity) and takes care of idiosyncasies like historic version dependence."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:105
msgid "The libraries that are provided in the standalone packages are also included in the all-encompassing ``intel-parallel-studio``. To complicate matters a bit, that package is sold in 3 \"editions\", of which only the upper-tier ``cluster`` edition supports *compiling* MPI applications, and hence only that edition can provide the ``mpi`` virtual package.  (As mentioned [fn2]_, all editions provide support for *running* MPI applications.)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:112
msgid "The edition forms the leading part of the version number for Spack's ``intel*`` packages discussed here. This differs from the primarily numeric version numbers seen with most other Spack packages. For example, we have:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:133
msgid "The full studio suite, capable of compiling MPI applications, currently requires about 12 GB of disk space when installed (see section `Install steps for packages with compilers and libraries`_ for detailed instructions). If you need to save disk space or installation time, you could install the ``intel`` compilers-only subset (0.6 GB) and just the library packages you need, for example ``intel-mpi`` (0.5 GB) and ``intel-mkl`` (2.5 GB)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:143
msgid "Unrelated packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:145
msgid "The following packages do not use the Intel installer and are not in class ``IntelPackage`` that is discussed here:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:148
msgid "``intel-gpu-tools`` -- Test suite and low-level tools for the Linux `Direct Rendering Manager <https://en.wikipedia.org/wiki/Direct_Rendering_Manager>`_"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:150
msgid "``intel-mkl-dnn`` -- Math Kernel Library for Deep Neural Networks (``CMakePackage``)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:151
msgid "``intel-xed`` -- X86 machine instructions encoder/decoder"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:152
msgid "``intel-tbb`` -- Standalone version of Intel Threading Building Blocks. Note that a TBB runtime version is included with ``intel-mkl``, and development versions are provided by the packages ``intel-parallel-studio`` (all editions) and its ``intel`` subset."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:159
msgid "Configuring Spack to use Intel licenses"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:161
msgid "If you wish to integrate licensed Intel products into Spack as external packages (`route 1`_ above) we assume that their license configuration is in place and is working [fn3]_. In this case, skip to section `Integration of Intel tools installed external to Spack`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:166
msgid "If you plan to have Spack install licensed products for you (`route 2`_ above), the Intel product installer that Spack will run underneath must have access to a license that is either provided by a *license server* or as a *license file*. The installer may be able to locate a license that is already configured on your system.  If it cannot, you must configure Spack to provide either the server location or the license file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:173
msgid "For authoritative information on Intel licensing, see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:175
msgid "https://software.intel.com/en-us/faq/licensing"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:176
msgid "https://software.intel.com/en-us/articles/how-do-i-manage-my-licenses"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:180
msgid "Pointing to an existing license server"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:182
msgid "Installing and configuring a license server is outside the scope of Spack. We assume that:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:185
msgid "Your system administrator has a license server running."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:186
msgid "The license server offers valid licenses for the Intel packages of interest."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:187
msgid "You can access these licenses under the user id running Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:189
msgid "Be aware of the difference between (a) installing and configuring a license server, and (b) configuring client software to *use* a server's so-called floating licenses.  We are concerned here with (b) only. The process of obtaining a license from a server for temporary use is called \"checking out a license\".  For that, a client application such as the Intel package installer or a compiler needs to know the host name and port number of one or more license servers that it may query [fn4]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:197
msgid "Follow one of three methods to `point client software to a floating license server <https://software.intel.com/en-us/articles/licensing-setting-up-the-client-floating-license>`_. Ideally, your license administrator will already have implemented one that can be used unchanged in Spack: Look for the environment variable ``INTEL_LICENSE_FILE`` or for files ``/opt/intel/licenses/*.lic`` that contain::"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:207
msgid "The relevant tokens, among possibly others, are the ``USE_SERVER`` line, intended specifically for clients, and one or more ``SERVER`` lines above it which give the network address."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:211
msgid "If you cannot find pre-existing ``/opt/intel/licenses/*.lic`` files and the ``INTEL_LICENSE_FILE`` environment variable is not set (even after you loaded any relevant modulefiles), ask your license administrator for the server address(es) and place them in a \"global\" license file within your Spack directory tree `as shown below <Spack-managed file_>`_)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:220
msgid "Installing a standalone license file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:222
msgid "If you purchased a user-specific license, follow `Intel's instructions <https://software.intel.com/en-us/faq/licensing#license-management>`_ to \"activate\" it for your serial number, then download the resulting license file. If needed, `request to have the file re-sent <https://software.intel.com/en-us/articles/resend-license-file>`_ to you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:228
msgid "Intel's license files are text files that contain tokens in the proprietary \"FLEXlm\" format and whose name ends in ``.lic``. Intel installers and compilers look for license files in several locations when they run. Place your license by one of the following means, in order of decreasing preference:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:233
msgid "Default directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:235
msgid "Install your license file in the directory ``/opt/intel/licenses/`` if you have write permission to it. This directory is inspected by all Intel tools and is therefore preferred, as no further configuration will be needed. Create the directory if it does not yet exist.  For the file name, either keep the downloaded name or use another suitably plain yet descriptive name that ends in ``.lic``. Adjust file permissions for access by licensed users."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:244
msgid "Directory given in environment variable"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:246
msgid "If you cannot use the default directory, but your system already has set the environment variable ``INTEL_LICENSE_FILE`` independent from Spack [fn5]_, then, if you have the necessary write permissions, place your license file in one of the directories mentioned in this environment variable.  Adjust file permissions to match licensed users."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:254
msgid "If your system has not yet set and used the environment variable ``INTEL_LICENSE_FILE``, you could start using it with the ``spack install`` stage of licensed tools and subsequent client packages. You would, however, be in a bind to always set that variable in the same manner, across updates and re-installations, and perhaps accommodate additions to it. As this may be difficult in the long run, we recommend that you do *not* attempt to start using the variable solely for Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:264
msgid "Spack-managed file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:266
msgid "The first time Spack encounters an Intel package that requires a license, it will initialize a Spack-global Intel-specific license file for you, as a template with instructional comments, and bring up an editor [fn6]_.  Spack will do this *even if you have a working license elsewhere* on the system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:271
msgid "To proceed with an externally configured license, leave the newly templated file as is (containing comments only) and close the editor. You do not need to touch the file again."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:275
msgid "To configure your own standalone license, copy the contents of your downloaded license file into the opened file, save it, and close the editor."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:278
msgid "To use a license server (i.e., a floating network license) that is not already configured elsewhere on the system, supply your license server address(es) in the form of ``SERVER`` and ``USE_SERVER`` lines at the *beginning of the file* [fn7]_, in the format shown in section `Pointing to an existing license server`_. Save the file and close the editor."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:284
msgid "To revisit and manually edit this file, such as prior to a subsequent installation attempt, find it at ``$SPACK_ROOT/etc/spack/licenses/intel/intel.lic`` ."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:288
msgid "Spack will place symbolic links to this file in each directory where licensed Intel binaries were installed.  If you kept the template unchanged, Intel tools will simply ignore it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:297
msgid "Integration of Intel tools installed *external* to Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:299
msgid "This section discusses `route 1`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:301
msgid "A site that already uses Intel tools, especially licensed ones, will likely have some versions already installed on the system, especially at a time when Spack is just being introduced. It will be useful to make such previously installed tools available for use by Spack as they are. How to do this varies depending on the type of the tools:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:309
msgid "Integrating external compilers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:311
msgid "For Spack to use external Intel compilers, you must tell it both *where* to find them and *when* to use them.  The present section documents the \"where\" aspect, involving ``compilers.yaml`` and, in most cases, long absolute paths. The \"when\" aspect actually relates to `route 3`_ and requires explicitly stating the compiler as a spec component (in the form ``foo %intel`` or ``foo %intel@compilerversion``) when installing client packages or altering Spack's compiler default in ``packages.yaml``. See section `Selecting Intel compilers <Selecting Intel compilers_>`_ for details."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:320
msgid "To integrate a new set of externally installed Intel compilers into Spack follow section :ref:`Compiler configuration <compiler-config>`. Briefly, prepare your shell environment like you would if you were to use these compilers normally, i.e., typically by a ``module load ...`` or a shell ``source ...`` command, then use ``spack compiler find`` to make Spack aware of these compilers.  This will create a new entry in a suitably scoped and possibly new ``compilers.yaml`` file. You could certainly create such a compiler entry manually, but this is error-prone due to the indentation and different data types involved."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:331
msgid "The Intel compilers need and use the system's native GCC compiler (``gcc`` on most systems, ``clang`` on macOS) to provide certain functionality, notably to support C++. To provide a different GCC compiler for the Intel tools, or more generally set persistent flags for all invocations of the Intel compilers, locate the ``compilers.yaml`` entry that defines your Intel compiler, and, using a text editor, change one or both of the following:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:338
msgid "At the ``modules:`` tag, add a ``gcc`` module to the list."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:339
msgid "At the ``flags:`` tag, add ``cflags:``, ``cxxflags:``, and ``fflags:`` key-value entries."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:341
msgid "Consult the examples under :ref:`Compiler configuration <compiler-config>` and :ref:`Vendor-Specific Compiler Configuration <vendor-specific-compiler-configuration>` in the Spack documentation. When done, validate your compiler definition by running ``spack compiler info intel@compilerversion`` (replacing ``compilerversion`` by the version that you defined)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:350
msgid "Be aware that both the GCC integration and persistent compiler flags can also be affected by an advanced third method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:353
msgid "A modulefile that provides the Intel compilers for you could, for the benefit of users outside of Spack, implicitly integrate a specific ``gcc`` version via compiler flag environment variables or (hopefully not) via a sneaky extra ``PATH`` addition."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:358
msgid "Next, visit section `Selecting Intel Compilers`_ to learn how to tell Spack to use the newly configured compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:363
msgid "Integrating external libraries"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:365
msgid "Configure external library-type packages (as opposed to compilers) in the files ``$SPACK_ROOT/etc/spack/packages.yaml`` or ``~/.spack/packages.yaml``, following the Spack documentation under :ref:`External Packages <sec-external-packages>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:370
msgid "Similar to ``compilers.yaml``, the ``packages.yaml`` files define a package external to Spack in terms of a Spack spec and resolve each such spec via either the ``paths`` or ``modules`` tokens to a specific pre-installed package version on the system.  Since Intel tools generally need environment variables to interoperate, which cannot be conveyed in a mere ``paths`` specification, the ``modules`` token will be more sensible to use. It resolves the Spack-side spec to a modulefile generated and managed outside of Spack's purview, which Spack will load internally and transiently when the corresponding spec is called upon to compile client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:380
msgid "Unlike for compilers, where ``spack find compilers [spec]`` generates an entry in an existing or new ``compilers.yaml`` file, Spack does not offer a command to generate an entirely new ``packages.yaml`` entry.  You must create new entries yourself in a text editor, though the command ``spack config [--scope=...] edit packages`` can help with selecting the proper file. See section :ref:`Configuration Scopes <configuration-scopes>` for an explanation about the different files and section :ref:`Build customization <build-settings>` for specifics and examples for ``packages.yaml`` files."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:400
msgid "The following example integrates packages embodied by hypothetical external modulefiles ``intel-mkl/18/...`` into Spack as packages ``intel-mkl@...``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:408
msgid "Make sure the file begins with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:414
msgid "Adapt the following example. Be sure to maintain the indentation:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:425
msgid "The version numbers for the ``intel-mkl`` specs defined here correspond to file and directory names that Intel uses for its products because they were adopted and declared as such within Spack's package repository. You can inspect the versions known to your current Spack installation by:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:434
msgid "Using the same version numbers for external packages as for packages known internally is useful for clarity, but not strictly necessary.  Moreover, with a ``packages.yaml`` entry, you can go beyond internally known versions."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:440
msgid "Note that the Spack spec in the example does not contain a compiler specification. This is intentional, as the Intel library packages can be used unmodified with different compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:444
msgid "A slightly more advanced example illustrates how to provide :ref:`variants <basic-variants>` and how to use the ``buildable: False`` directive to prevent Spack from installing other versions or variants of the named package through its normal internal mechanism."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:459
msgid "One additional example illustrates the use of ``paths:`` instead of ``modules:``, useful when external modulefiles are not available or not suitable:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:472
msgid "Note that for the Intel packages discussed here, the directory values in the ``paths:`` entries must be the high-level and typically version-less \"installation directory\" that has been used by Intel's product installer. Such a directory will typically accumulate various product versions.  Amongst them, Spack will select the correct version-specific product directory based on the ``@version`` spec component that each path is being defined for."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:479
msgid "For further background and details, see :ref:`External Packages <sec-external-packages>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:485
msgid "Installing Intel tools *within* Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:487
msgid "This section discusses `route 2`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:489
msgid "When a system does not yet have Intel tools installed already, or the installed versions are undesirable, Spack can install these tools like any regular Spack package for you and, with appropriate pre- and post-install configuration, use its compilers and/or libraries to install client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:498
msgid "Install steps for packages with compilers and libraries"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:500
msgid "The packages ``intel-parallel-studio`` and ``intel`` (which is a subset of the former) are many-in-one products that contain both compilers and a set of library packages whose scope depends on the edition. Because they are general products geared towards shell environments, it can be somewhat involved to integrate these packages at their full extent into Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:507
msgid "Note: To install library-only packages like ``intel-mkl``, ``intel-mpi``, and ``intel-daal`` follow `the next section <intel-install-libs_>`_ instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:510
msgid "Review the section `Configuring spack to use intel licenses`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:514
msgid "To install a version of ``intel-parallel-studio`` that provides Intel compilers at a version that you have *not yet declared in Spack*, the following preparatory steps are recommended:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:518
msgid "Determine the compiler spec that the new ``intel-parallel-studio`` package will provide, as follows: From the package version, combine the last two digits of the version year, a literal \"0\" (zero), and the version component that immediately follows the year."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:524
msgid "Package version"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:524
msgid "Compiler spec provided"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:526
msgid "``intel-parallel-studio@edition.YYyy.u``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:526
msgid "``intel@yy.0.u``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:529
msgid "Example: The package ``intel-parallel-studio@cluster.2018.3`` will provide the compiler with spec ``intel@18.0.3``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:534
msgid "Add a new compiler section with the newly anticipated version at the end of a ``compilers.yaml`` file in a suitable scope.  For example, run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:541
msgid "and append a stub entry:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:556
msgid "Replace ``18.0.3`` with the version that you determined in the preceeding step. The contents under ``paths:`` do not matter yet."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:559
msgid "You are right to ask: \"Why on earth is that necessary?\" [fn8]_. The answer lies in Spack striving for strict compiler consistency. Consider what happens without such a pre-declared compiler stub: Say, you ask Spack to install a particular version ``intel-parallel-studio@edition.V``.  Spack will apply an unrelated compiler spec to concretize and install your request, resulting in ``intel-parallel-studio@edition.V %X``. That compiler ``%X`` is not going to be the version that this new package itself provides. Rather, it would typically be ``%gcc@...`` in a default Spack installation or possibly indeed ``%intel@...``, but at a version that precedes ``V``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:570
msgid "The problem comes to the fore as soon as you try to use any virtual ``mkl`` or ``mpi`` packages that you would expect to now be provided by ``intel-parallel-studio@edition.V``.  Spack will indeed see those virtual packages, but only as being tied to the compiler that the package ``intel-parallel-studio@edition.V`` was concretized with *at installation*. If you were to install a client package with the new compilers now available to you, you would naturally run ``spack install foo +mkl %intel@V``, yet Spack will either complain about ``mkl%intel@V`` being missing (because it only knows about ``mkl%X``) or it will go and attempt to install *another instance* of ``intel-parallel-studio@edition.V %intel@V`` so as to match the compiler spec ``%intel@V`` that you gave for your client package ``foo``. This will be unexpected and will quickly get annoying because each reinstallation takes up time and extra disk space."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:584
msgid "To escape this trap, put the compiler stub declaration shown here in place, then use that pre-declared compiler spec to install the actual package, as shown next.  This approach works because during installation only the package's own self-sufficient installer will be used, not any compiler."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:591
msgid "Verify that the compiler version provided by the new ``studio`` version would be used as expected if you were to compile a client package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:598
msgid "If the version does not match, explicitly state the anticipated compiler version, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:604
msgid "if there are problems, review and correct the compiler's ``compilers.yaml`` entry, be it still in stub form or already complete (as it would be for a re-installation)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:608
msgid "Install the new ``studio`` package using Spack's regular ``install`` command. It may be wise to provide the anticipated compiler (`see above <verify-compiler-anticipated_>`_) as an explicit concretization element:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:618
msgid "Follow the same steps as under `Integrating external compilers`_ to tell Spack the minutiae for actually using those compilers with client packages. If you placed a stub entry in a ``compilers.yaml`` file, now is the time to edit it and fill in the particulars."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:623
msgid "Under ``paths:``, give the full paths to the actual compiler binaries (``icc``, ``ifort``, etc.) located within the Spack installation tree, in all their unsightly length [fn9]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:627
msgid "To determine the full path to the C compiler, adapt and run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:634
msgid "If you get hits for both ``intel64`` and ``ia32``, you almost certainly will want to use the ``intel64`` variant.  The ``icpc`` and ``ifort`` compilers will be located in the same directory as ``icc``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:638
msgid "Use the ``modules:`` and/or ``cflags:`` tokens to specify a suitable accompanying ``gcc`` version to help pacify picky client packages that ask for C++ standards more recent than supported by your system-provided ``gcc`` and its ``libstdc++.so``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:643
msgid "To set the Intel compilers for default use in Spack, instead of the usual ``%gcc``, follow section `Selecting Intel compilers`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:648
msgid "Compiler packages like ``intel-parallel-studio`` can easily be above 10 GB in size, which can tax the disk space available for temporary files on small, busy, or restricted systems (like virtual machines). The Intel installer will stop and report insufficient space as::"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:658
msgid "As first remedy, clean Spack's existing staging area:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:664
msgid "then retry installing the large package. Spack normally cleans staging directories but certain failures may prevent it from doing so."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:667
msgid "If the error persists, tell Spack to use an alternative location for temporary files:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:670
msgid "Run ``df -h`` to identify an alternative location on your system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:672
msgid "Tell Spack to use that location for staging. Do **one** of the following:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:674
msgid "Run Spack with the environment variable ``TMPDIR`` altered for just a single command. For example, to use your ``$HOME`` directory:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:681
msgid "This example uses Bourne shell syntax. Adapt for other shells as needed."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:683
msgid "Alternatively, customize Spack's ``build_stage`` :ref:`configuration setting <config-overrides>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:690
msgid "Append:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:698
msgid "Do not duplicate the ``config:`` line if it already is present. Adapt the location, which here is the same as in the preceeding example."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:701
msgid "Retry installing the large package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:708
msgid "Install steps for library-only packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:710
msgid "To install library-only packages like ``intel-mkl``, ``intel-mpi``, and ``intel-daal`` follow the steps given here. For packages that contain a compiler, follow `the previous section <intel-install-studio_>`_ instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:715
msgid "For pre-2017 product releases, review the section `Configuring Spack to use Intel licenses`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:717
msgid "Inspect the package spec. Specify an explicit compiler if necessary, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:724
msgid "Check that the package will use the compiler flavor and version that you expect."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:726
msgid "Install the package normally within Spack. Use the same spec as in the previous command, i.e., as general or as specific as needed:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:734
msgid "To prepare the new packages for use with client packages, follow `Selecting libraries to satisfy virtual packages`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:740
msgid "Debug notes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:742
msgid "You can trigger a wall of additional diagnostics using Spack options, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:748
msgid "The ``--debug`` option can also be useful while installing client packages `(see below) <Using Intel tools in Spack to install client packages_>`_ to confirm the integration of the Intel tools in Spack, notably MKL and MPI."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:753
msgid "The ``.spack/`` subdirectory of an installed ``IntelPackage`` will contain, besides Spack's usual archival items, a copy of the ``silent.cfg`` file that was passed to the Intel installer:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:762
msgid "If an installation error occurs, Spack will normally clean up and remove a partially installed target directory. You can direct Spack to keep it using ``--keep-prefix``, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:770
msgid "You must, however, *remove such partial installations* prior to subsequent installation attempts. Otherwise, the Intel installer will behave incorrectly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:777
msgid "Using Intel tools in Spack to install client packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:779
msgid "Finally, this section pertains to `route 3`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:781
msgid "Once Intel tools are installed within Spack as external or internal packages they can be used as intended for installing client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:789
msgid "Selecting Intel compilers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:791
msgid "Select Intel compilers to compile client packages, like any compiler in Spack, by one of the following means:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:794
msgid "Request the Intel compilers explicitly in the client spec, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:801
msgid "Alternatively, request Intel compilers implicitly by concretization preferences. Configure the order of compilers in the appropriate ``packages.yaml`` file, under either an ``all:`` or client-package-specific entry, in a ``compiler:`` list. Consult the Spack documentation for :ref:`Configuring Package Preferences <configs-tutorial-package-prefs>` and :ref:`Concretization Preferences <concretization-preferences>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:809
msgid "Example: ``etc/spack/packages.yaml`` might simply contain:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:817
msgid "To be more specific, you can state partial or full compiler version numbers, for example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:830
msgid "Selecting libraries to satisfy virtual packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:832
msgid "Intel packages, whether integrated into Spack as external packages or installed within Spack, can be called upon to satisfy the requirement of a client package for a library that is available from different providers. The relevant virtual packages for Intel are ``blas``, ``lapack``, ``scalapack``, and ``mpi``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:838
msgid "In both integration routes, Intel packages can have optional :ref:`variants <basic-variants>` which alter the list of virtual packages they can satisfy.  For Spack-external packages, the active variants are a combination of the defaults declared in Spack's package repository and the spec it is declared as in ``packages.yaml``. Needless to say, those should match the components that are actually present in the external product installation. Likewise, for Spack-internal packages, the active variants are determined, persistently at installation time, from the defaults in the repository and the spec selected to be installed."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:848
msgid "To have Intel packages satisfy virtual package requests for all or selected client packages, edit the ``packages.yaml`` file.  Customize, either in the ``all:`` or a more specific entry, a ``providers:`` dictionary whose keys are the virtual packages and whose values are the Spack specs that satisfy the virtual package, in order of decreasing preference.  To learn more about the ``providers:`` settings, see the Spack tutorial for :ref:`Configuring Package Preferences <configs-tutorial-package-prefs>` and the section :ref:`Concretization Preferences <concretization-preferences>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:858
msgid "Example: The following fairly minimal example for ``packages.yaml`` shows how to exclusively use the standalone ``intel-mkl`` package for all the linear algebra virtual packages in Spack, and ``intel-mpi`` as the preferred MPI implementation. Other providers can still be chosen on a per-package basis."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:873
msgid "If you have access to the ``intel-parallel-studio@cluster`` edition, you can use instead:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:886
msgid "If you installed ``intel-parallel-studio`` within Spack (\"`route 2`_\"), make sure you followed the `special installation step <intel-compiler-anticipation_>`_ to ensure that its virtual packages match the compilers it provides."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:894
msgid "Using Intel tools as explicit dependency"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:896
msgid "With the proper installation as detailed above, no special steps should be required when a client package specifically (and thus deliberately) requests an Intel package as dependency, this being one of the target use cases for Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:903
msgid "Tips for configuring client packages to use MKL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:905
msgid "The Math Kernel Library (MKL) is provided by several Intel packages, currently ``intel-parallel-studio`` when variant ``+mkl`` is active (it is by default) and the standalone ``intel-mkl``. Because of these different provider packages, a *virtual* ``mkl`` package is declared in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:910
msgid "To use MKL-specific APIs in a client package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:912
msgid "Declare a dependency on ``mkl``, rather than a specific provider like ``intel-mkl``.  Declare the dependency either absolutely or conditionally based on variants that your package might have declared:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:923
msgid "The ``MKLROOT`` environment variable (part of the documented API) will be set during all stages of client package installation, and is available to both the Spack packaging code and the client code."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:927
msgid "To use MKL as provider for BLAS, LAPACK, or ScaLAPACK:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:929
msgid "The packages that provide ``mkl`` also provide the narrower virtual ``blas``, ``lapack``, and ``scalapack`` packages. See the relevant :ref:`Packaging Guide section <blas_lapack_scalapack>` for an introduction. To portably use these virtual packages, construct preprocessor and linker option strings in your package configuration code using the package functions ``.headers`` and ``.libs`` in conjunction with utility functions from the following classes:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:938
msgid ":py:class:`llnl.util.filesystem.FileList`,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:939
msgid ":py:class:`llnl.util.filesystem.HeaderList`,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:940
msgid ":py:class:`llnl.util.filesystem.LibraryList`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:943
msgid "*Do not* use constructs like ``.prefix.include`` or ``.prefix.lib``, with Intel or any other implementation of ``blas``, ``lapack``, and ``scalapack``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:947
msgid "For example, for an :ref:`AutotoolsPackage <autotoolspackage>` use ``.libs.ld_flags`` to transform the library file list into linker options passed to ``./configure``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:962
msgid "Even though ``.ld_flags`` will return a string of multiple words, *do not* use quotes for options like ``--with-blas=...`` because Spack passes them to ``./configure`` without invoking a shell."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:966
msgid "Likewise, in a :ref:`MakefilePackage <makefilepackage>` or similiar package that does not use AutoTools you may need to provide include and link options for use on command lines or in environment variables. For example, to generate an option string of the form ``-I<dir>``, use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:976
msgid "and to generate linker options (``-L<dir> -llibname ...``), use the same as above,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:982
msgid "See :ref:`MakefilePackage <makefilepackage>` and more generally the :ref:`Packaging Guide <blas_lapack_scalapack>` for background and further examples."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:991
msgid "Footnotes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:993
msgid "Strictly speaking, versions from ``2017.2`` onward."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:995
msgid "The package ``intel`` intentionally does not have a ``+mpi`` variant since it is meant to be small. The native installer will always add MPI *runtime* components because it follows defaults defined in the download package, even when ``intel-parallel-studio ~mpi`` has been requested."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1000
msgid "For ``intel-parallel-studio +mpi``, the class function :py:func:``.IntelPackage.pset_components`` will include ``\"intel-mpi intel-imb\"`` in a list of component patterns passed to the Intel installer. The installer will extend each pattern word with an implied glob-like ``*`` to resolve it to package names that are *actually present in the product BOM*. As a side effect, this pattern approach accommodates occasional package name changes, e.g., capturing both ``intel-mpirt`` and ``intel-mpi-rt`` ."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1009
msgid "How could the external installation have succeeded otherwise?"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1011
msgid "According to Intel's documentation, there is supposedly a way to install a product using a network license even `when a FLEXlm server is not running <https://software.intel.com/en-us/articles/licensing-setting-up-the-client-floating-license>`_: Specify the license in the form ``port@serverhost`` in the ``INTEL_LICENSE_FILE`` environment variable. All other means of specifying a network license require that the license server be up."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1018
msgid "Despite the name, ``INTEL_LICENSE_FILE`` can hold several and diverse entries. They  can be either directories (presumed to contain ``*.lic`` files), file names, or network locations in the form ``port@host`` (on Linux and Mac), with all items separated by \":\" (on Linux and Mac)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1023
msgid "Should said editor turn out to be ``vi``, you better be in a position to know how to use it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1026
msgid "Comment lines in FLEXlm files, indicated by ``#`` as the first non-whitespace character on the line, are generally allowed anywhere in the file. There `have been reports <https://github.com/spack/spack/issues/6534>`_, however, that as of 2018, ``SERVER`` and ``USE_SERVER`` lines must precede any comment lines."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1037
msgid "Spack's close coupling of installed packages to compilers, which both necessitates the detour for installing ``intel-parallel-studio``, and largely limits any of its provided virtual packages to a single compiler, heavily favors `recommending to install Intel Parallel Studio outside of Spack <integrate-external-intel_>`_ and declare it for Spack in ``packages.yaml`` by a `compiler-less spec <compiler-neutral-package_>`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1044
msgid "With some effort, you can convince Spack to use shorter paths."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1046
msgid "Altering the naming scheme means that Spack will lose track of all packages it has installed for you so far. That said, the time is right for this kind of customization when you are defining a new set of compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1051
msgid "The relevant tunables are:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1053
msgid "Set the ``install_tree`` location in ``config.yaml`` (:ref:`see doc <config-yaml>`)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1055
msgid "Set the hash length in ``install-path-scheme``, also in ``config.yaml`` (:ref:`q.v. <config-yaml>`)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1057
msgid "You will want to set the *same* hash length for :ref:`tcl module files <modules-naming-scheme>` if you have Spack produce them for you, under ``naming_scheme`` in ``modules.yaml``.  Other module dialects cannot be altered in this manner."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:10
msgid "MakefilePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:12
msgid "The most primitive build system a package can use is a plain Makefile. Makefiles are simple to write for small projects, but they usually require you to edit the Makefile to set platform and compiler-specific variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:21
msgid "The ``MakefilePackage`` base class comes with 3 phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:23
msgid "``edit`` - edit the Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:24
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:23
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:35
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:22
msgid "``build`` - build the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:25
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:24
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:36
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:23
msgid "``install`` - install the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:27
msgid "By default, ``edit`` does nothing, but you can override it to replace hard-coded Makefile variables. The ``build`` and ``install`` phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:41
msgid "The main file that matters for a ``MakefilePackage`` is the Makefile. This file will be named one of the following ways:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:44
msgid "GNUmakefile (only works with GNU Make)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:45
msgid "Makefile (most common)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:46
msgid "makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:48
msgid "Some Makefiles also *include* other configuration files. Check for an ``include`` directive in the Makefile."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:55
msgid "Spack assumes that the operating system will have a valid ``make`` utility installed already, so you don't need to add a dependency on ``make``. However, if the package uses a ``GNUmakefile`` or the developers recommend using GNU Make, you should add a dependency on ``gmake``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:67
msgid "Types of Makefile packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:69
msgid "Most of the work involved in packaging software that uses Makefiles involves overriding or replacing hard-coded variables. Many packages make the mistake of hard-coding compilers, usually for GCC or Intel. This is fine if you happen to be using that particular compiler, but Spack is designed to work with *any* compiler, and you need to ensure that this is the case."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:76
msgid "Depending on how the Makefile is designed, there are 4 common strategies that can be used to set or override the appropriate variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:81
msgid "Environment variables"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:83
msgid "Make has multiple types of `assignment operators <https://www.gnu.org/software/make/manual/make.html#Setting>`_. Some Makefiles use ``=`` to assign variables. The only way to override these variables is to edit the Makefile or override them on the command-line. However, Makefiles that use ``?=`` for assignment honor environment variables. Since Spack already sets ``CC``, ``CXX``, ``F77``, and ``FC``, you won't need to worry about setting these variables. If there are any other variables you need to set, you can do this in the ``edit`` method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:100
msgid "`cbench <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cbench/package.py>`_ is a good example of a simple package that does this, while `esmf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/esmf/package.py>`_ is a good example of a more complex package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:107
msgid "Command-line arguments"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:109
msgid "If the Makefile ignores environment variables, the next thing to try is command-line arguments. You can do this by overriding the ``build_targets`` attribute. If you don't need access to the spec, you can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:119
msgid "If you do need access to the spec, you can create a property like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:133
msgid "`cloverleaf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cloverleaf/package.py>`_ is a good example of a package that uses this strategy."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:138
msgid "Edit Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:140
msgid "Some Makefiles are just plain stubborn and will ignore command-line variables. The only way to ensure that these packages build correctly is to directly edit the Makefile. Spack provides a ``FileFilter`` class and a ``filter_file`` method to help with this. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:154
msgid "`stream <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/stream/package.py>`_ is a good example of a package that involves editing a Makefile to set the appropriate variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:160
msgid "Config file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:162
msgid "More complex packages often involve Makefiles that *include* a configuration file. These configuration files are primarily composed of variables relating to the compiler, platform, and the location of dependencies or names of libraries. Since these config files are dependent on the compiler and platform, you will often see entire directories of examples for common compilers and architectures. Use these examples to help determine what possible values to use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:170
msgid "If the config file is long and only contains one or two variables that need to be modified, you can use the technique above to edit the config file. However, if you end up needing to modify most of the variables, it may be easier to write a new file from scratch."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:175
msgid "If each variable is independent of each other, a dictionary works well for storing variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:194
msgid "`elk <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/elk/package.py>`_ is a good example of a package that uses a dictionary to store configuration variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:198
msgid "If the order of variables is important, it may be easier to store them in a list:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:215
msgid "`hpl <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/hpl/package.py>`_ is a good example of a package that uses a list to store configuration variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:221
msgid "Variables to watch out for"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:223
msgid "The following is a list of common variables to watch out for. The first two sections are `implicit variables <https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html>`_ defined by Make and will always use the same name, while the rest are user-defined variables and may vary from package to package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:229
msgid "**Compilers**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:231
msgid "This includes variables such as ``CC``, ``CXX``, ``F77``, ``F90``, and ``FC``, as well as variables related to MPI compiler wrappers, like ``MPICC`` and friends."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:235
msgid "**Compiler flags**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:237
msgid "This includes variables for specific compilers, like ``CFLAGS``, ``CXXFLAGS``, ``F77FLAGS``, ``F90FLAGS``, ``FCFLAGS``, and ``CPPFLAGS``. These variables are often hard-coded to contain flags specific to a certain compiler. If these flags don't work for every compiler, you may want to consider filtering them."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:243
msgid "**Variables that enable or disable features**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:245
msgid "This includes variables like ``MPI``, ``OPENMP``, ``PIC``, and ``DEBUG``. These flags often require you to create a variant so that you can either build with or without MPI support, for example. These flags are often compiler-dependent. You should replace them with the appropriate compiler flags, such as ``self.compiler.openmp_flag`` or ``self.compiler.pic_flag``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:252
msgid "**Platform flags**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:254
msgid "These flags control the type of architecture that the executable is compiler for. Watch out for variables like ``PLAT`` or ``ARCH``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:257
msgid "**Dependencies**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:259
msgid "Look out for variables that sound like they could be used to locate dependencies, such as ``JAVA_HOME``, ``JPEG_ROOT``, or ``ZLIBDIR``. Also watch out for variables that control linking, such as ``LIBS``, ``LDFLAGS``, and ``INCLUDES``. These variables need to be set to the installation prefix of a dependency, or to the correct linker flags to link to that dependency."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:266
msgid "**Installation prefix**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:268
msgid "If your Makefile has an ``install`` target, it needs some way of knowing where to install. By default, many packages install to ``/usr`` or ``/usr/local``. Since many Spack users won't have sudo privileges, it is imperative that each package is installed to the proper prefix. Look for variables like ``PREFIX`` or ``INSTALL``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:277
msgid "Makefiles in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:279
msgid "Not every package places their Makefile in the root of the package tarball. If the Makefile is in a sub-directory like ``src``, you can tell Spack where to locate it like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:290
msgid "Manual installation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:292
msgid "Not every Makefile includes an ``install`` target. If this is the case, you can override the default ``install`` method to manually install the package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:308
msgid "For more information on reading and writing Makefiles, see: https://www.gnu.org/software/make/manual/make.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:10
msgid "MesonPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:12
msgid "Much like Autotools and CMake, Meson is a build system.  But it is meant to be both fast and as user friendly as possible.  GNOME's goal is to port modules to use the Meson build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:20
msgid "The ``MesonPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:22
msgid "``meson`` - generate ninja files"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:38
msgid "Any of these phases can be overridden in your package as necessary. There is also a ``check`` method that looks for a ``test`` target in the build file. If a ``test`` target exists and the user runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:47
msgid "Spack will run ``ninja test`` after the build phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:53
msgid "Packages that use the Meson build system can be identified by the presence of a ``meson.build`` file. This file declares things like build instructions and dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:57
msgid "One thing to look for is the ``meson_version`` key that gets passed to the ``project`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:76
msgid "This means that Meson 0.43.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:83
msgid "At the bare minimum, packages that use the Meson build system need ``meson`` and ```ninja``` dependencies. Since this is always the case, the ``MesonPackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:104
msgid "Finding meson flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:106
msgid "To get a list of valid flags that can be passed to ``meson``, run the following command in the directory that contains ``meson.build``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:116
msgid "Passing arguments to meson"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:118
msgid "If you need to pass any arguments to the ``meson`` call, you can override the ``meson_args`` method like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:127
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:109
msgid "This method can be used to pass flags as well as variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:133
msgid "For more information on the Meson build system, see: https://mesonbuild.com/index.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:10
msgid "OctavePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:12
msgid "Octave has its own build system for installing packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:18
msgid "The ``OctavePackage`` base class has a single phase:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:22
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:26
msgid "By default, this phase runs the following command:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:29
msgid "Beware that uninstallation is not implemented at the moment. After uninstalling a package via Spack, you also need to manually uninstall it from Octave via ``pkg uninstall <package_name>``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:35
msgid "Finding Octave packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:37
msgid "Most Octave packages are listed at https://octave.sourceforge.io/packages.php."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:41
msgid "Dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:43
msgid "Usually, the homepage of a package will list dependencies, i.e. ``Dependencies: Octave >= 3.6.0 struct >= 1.0.12``. The same information should be available in the ``DESCRIPTION`` file in the root of each archive."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:49
msgid "External Documentation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:51
msgid "For more information on the Octave build system, see: https://octave.org/doc/v4.4.0/Installing-and-Removing-Packages.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:10
msgid "PerlPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:12
msgid "Much like Octave, Perl has its own language-specific build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:19
msgid "The ``PerlPackage`` base class comes with 3 phases that can be overridden:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:21
msgid "``configure`` - configure the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:25
msgid "Perl packages have 2 common modules used for module installation:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:29
msgid "``ExtUtils::MakeMaker``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:31
msgid "The ``ExtUtils::MakeMaker`` module is just what it sounds like, a module designed to generate Makefiles. It can be identified by the presence of a ``Makefile.PL`` file, and has the following installation steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:45
msgid "``Module::Build``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:47
msgid "The ``Module::Build`` module is a pure-Perl build system, and can be identified by the presence of a ``Build.PL`` file. It has the following installation steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:59
msgid "If both ``Makefile.PL`` and ``Build.PL`` files exist in the package, Spack will use ``Makefile.PL`` by default. If your package uses a different module, ``PerlPackage`` will need to be extended to support it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:64
msgid "``PerlPackage`` automatically detects which build steps to use, so there shouldn't be much work on the package developer's side to get things working."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:70
msgid "Finding Perl packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:72
msgid "Most Perl modules are hosted on CPAN - The Comprehensive Perl Archive Network. If you need to find a package for ``XML::Parser``, for example, you should search for \"CPAN XML::Parser\"."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:76
msgid "Some CPAN pages are versioned. Check for a link to the \"Latest Release\" to make sure you have the latest version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:81
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:52
msgid "Package name"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:83
msgid "When you use ``spack create`` to create a new Perl package, Spack will automatically prepend ``perl-`` to the front of the package name. This helps to keep Perl modules separate from other packages. The same naming scheme is used for other language extensions, like Python and R."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:90
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:113
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:73
msgid "Description"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:92
msgid "Most CPAN pages have a short description under \"NAME\" and a longer description under \"DESCRIPTION\". Use whichever you think is more useful while still being succinct."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:98
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:129
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:87
msgid "Homepage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:100
msgid "In the top-right corner of the CPAN page, you'll find a \"permalink\" for the package. This should be used instead of the current URL, as it doesn't contain the version number and will always link to the latest release."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:107
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:145
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:102
msgid "URL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:109
msgid "If you haven't found it already, the download URL is on the right side of the page below the permalink. Search for \"Download\"."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:116
msgid "Every ``PerlPackage`` obviously depends on Perl at build and run-time, so ``PerlPackage`` contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:126
msgid "If your package requires a specific version of Perl, you should specify this."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:129
msgid "Although newer versions of Perl include ``ExtUtils::MakeMaker`` and ``Module::Build`` as \"core\" modules, you may want to add dependencies on ``perl-extutils-makemaker`` and ``perl-module-build`` anyway. Many people add Perl as an external package, and we want the build to work properly. If your package uses ``Makefile.PL`` to build, add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:140
msgid "If your package uses ``Build.PL`` to build, add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:149
msgid "Perl dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:151
msgid "Below the download URL, you will find a \"Dependencies\" link, which takes you to a page listing all of the dependencies of the package. Packages listed as \"Core module\" don't need to be added as dependencies, but all direct dependencies should be added. Don't add dependencies of dependencies. These should be added as dependencies to the dependency, not to your package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:160
msgid "Passing arguments to configure"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:162
msgid "Packages that have non-Perl dependencies often use command-line variables to specify their installation directory. You can pass arguments to ``Makefile.PL`` or ``Build.PL`` by overriding ``configure_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:180
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:720
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:312
msgid "Alternatives to Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:182
msgid "If you need to maintain a stack of Perl modules for a user and don't want to add all of them to Spack, a good alternative is ``cpanm``. If Perl is already installed on your system, it should come with a ``cpan`` executable. To install ``cpanm``, run the following command:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:192
msgid "Now, you can install any Perl module you want by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:199
msgid "Obviously, these commands can only be run if you have root privileges. Furthermore, ``cpanm`` is not capable of installing non-Perl dependencies. If you need to install to your home directory or need to install a module with non-Perl dependencies, Spack is a better option."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:208
msgid "You can find more information on installing Perl modules from source at: http://www.perlmonks.org/?node_id=128077"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:211
msgid "More generic Perl module installation instructions can be found at: http://www.cpan.org/modules/INSTALL.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:10
msgid "PythonPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:12
msgid "Python packages and modules have their own special build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:18
msgid "The ``PythonPackage`` base class provides the following phases that can be overridden:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:21
msgid "``build``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:22
msgid "``build_py``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:23
msgid "``build_ext``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:24
msgid "``build_clib``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:25
msgid "``build_scripts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:26
msgid "``clean``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:27
msgid "``install``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:28
msgid "``install_lib``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:29
msgid "``install_headers``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:30
msgid "``install_scripts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:31
msgid "``install_data``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:32
msgid "``sdist``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:33
msgid "``register``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:34
msgid "``bdist``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:35
msgid "``bdist_dumb``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:36
msgid "``bdist_rpm``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:37
msgid "``bdist_wininst``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:38
msgid "``upload``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:39
msgid "``check``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:41
msgid "These are all standard ``setup.py`` commands and can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:48
msgid "By default, only the ``build`` and ``install`` phases are run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:50
msgid "``build`` - build everything needed to install"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:51
msgid "``install`` - install everything from build directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:53
msgid "If for whatever reason you need to run more phases, simply modify your ``phases`` list like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:61
msgid "Each phase provides a function ``<phase>`` that runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:68
msgid "Each phase also has a ``<phase_args>`` function that can pass arguments to this call. All of these functions are empty except for the ``install_args`` function, which passes ``--prefix=/path/to/installation/prefix``. There is also some additional logic specific to setuptools and eggs."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:73
msgid "If you need to run a phase that is not a standard ``setup.py`` command, you'll need to define a function for it like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:88
msgid "Python packages can be identified by the presence of a ``setup.py`` file. This file is used by package managers like ``pip`` to determine a package's dependencies and the version of dependencies required, so if the ``setup.py`` file is not accurate, the package will not build properly. For this reason, the ``setup.py`` file should be fairly reliable. If the documentation and ``setup.py`` disagree on something, the ``setup.py`` file should be considered to be the truth. As dependencies are added or removed, the documentation is much more likely to become outdated than the ``setup.py``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:100
msgid "Finding Python packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:102
msgid "The vast majority of Python packages are hosted on PyPI - The Python Package Index. ``pip`` only supports packages hosted on PyPI, making it the only option for developers who want a simple installation. Search for \"PyPI <package-name>\" to find the download page. Note that some pages are versioned, and the first result may not be the newest version. Click on the \"Latest Version\" button to the top right to see if a newer version is available. The download page is usually at: https://pypi.org/project/<package-name>"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:115
msgid "The top of the PyPI downloads page contains a description of the package. The first line is usually a short description, while there may be a several line \"Project Description\" that follows. Choose whichever is more useful. You can also get these descriptions on the command-line using:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:131
msgid "Package developers use ``setup.py`` to upload new versions to PyPI. The ``setup`` method often passes metadata like ``homepage`` to PyPI. This metadata is displayed on the left side of the download page. Search for the text \"Homepage\" under \"Project links\" to find it. You should use this page instead of the PyPI page if they differ. You can also get the homepage on the command-line by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:147
msgid "You may have noticed that Spack allows you to add multiple versions of the same package without adding multiple versions of the download URL. It does this by guessing what the version string in the URL is and replacing this with the requested version. Obviously, if Spack cannot guess the version correctly, or if non-version-related things change in the URL, Spack cannot substitute the version properly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:154
msgid "Once upon a time, PyPI offered nice, simple download URLs like: https://pypi.python.org/packages/source/n/numpy/numpy-1.13.1.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:157
msgid "As you can see, the version is 1.13.1. It probably isn't hard to guess what URL to use to download version 1.12.0, and Spack was perfectly capable of performing this calculation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:161
msgid "However, PyPI switched to a new download URL format: https://pypi.python.org/packages/c0/3a/40967d9f5675fbb097ffec170f59c2ba19fc96373e73ad47c2cae9a30aed/numpy-1.13.1.zip#md5=2c3c0f4edf720c3a7b525dacc825b9ae"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:164
msgid "and more recently: https://files.pythonhosted.org/packages/b0/2b/497c2bb7c660b2606d4a96e2035e92554429e139c6c71cdff67af66b58d2/numpy-1.14.3.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:167
msgid "As you can imagine, it is impossible for Spack to guess what URL to use to download version 1.12.0 given this URL. There is a solution, however. PyPI offers a new hidden interface for downloading Python packages that does not include a hash in the URL: https://pypi.io/packages/source/n/numpy/numpy-1.13.1.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:173
msgid "This URL redirects to the files.pythonhosted.org URL. The general syntax for this pypi.io URL is: https://pypi.io/packages/source/<first-letter-of-name>/<name>/<name>-<version>.<extension>"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:177
msgid "Please use the pypi.io URL instead of the pypi.python.org URL. If both ``.tar.gz`` and ``.zip`` versions are available, ``.tar.gz`` is preferred. If some releases offer both ``.tar.gz`` and ``.zip`` versions, but some only offer ``.zip`` versions, use ``.zip``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:184
msgid "PyPI vs. GitHub"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:186
msgid "Many packages are hosted on PyPI, but are developed on GitHub and other version control systems. The tarball can be downloaded from either location, but PyPI is preferred for the following reasons:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:190
msgid "PyPI contains the bare minimum of files to install the package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:192
msgid "You may notice that the tarball you download from PyPI does not have the same checksum as the tarball you download from GitHub. When a developer uploads a new release to PyPI, it doesn't contain every file in the repository, only the files necessary to install the package. PyPI tarballs are therefore smaller."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:198
msgid "PyPI is the official source for package managers like ``pip``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:200
msgid "Let's be honest, ``pip`` is much more popular than Spack. If the GitHub tarball contains a file not present in the PyPI tarball that causes a bug, the developers may not realize this for quite some time. If the bug was in a file contained in the PyPI tarball, users would notice the bug much more quickly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:206
msgid "GitHub release may be a beta version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:208
msgid "When a developer releases a new version of a package on GitHub, it may not be intended for most users. Until that release also makes its way to PyPI, it should be assumed that the release is not yet ready for general use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:213
msgid "The checksum for a GitHub release may change."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:215
msgid "Unfortunately, some developers have a habit of patching releases without incrementing the version number. This results in a change in tarball checksum. Package managers like Spack that use checksums to verify the integrity of a download tarball grind to a halt when the checksum for a known version changes. Most of the time, the change is intentional, and contains a needed bug fix. However, sometimes the change indicates a download source that has been compromised, and a tarball that contains a virus. If this happens, you must contact the developers to determine which is the case. PyPI is nice because it makes it physically impossible to re-release the same version of a package with a different checksum."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:227
msgid "There are some reasons to prefer downloading from GitHub:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:229
msgid "The GitHub tarball may contain unit tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:231
msgid "As previously mentioned, the PyPI tarball contains the bare minimum of files to install the package. Unless explicitly specified by the developers, it will not contain development files like unit tests. If you desire to run the unit tests during installation, you should use the GitHub tarball instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:237
msgid "Spack does not yet support ``spack versions`` and ``spack checksum`` with PyPI URLs"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:240
msgid "These commands work just fine with GitHub URLs. This is a minor annoyance, not a reason to prefer GitHub over PyPI."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:243
msgid "If you really want to run these unit tests, no one will stop you from submitting a PR for a new package that downloads from GitHub."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:250
msgid "There are a few dependencies common to the ``PythonPackage`` build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:254
msgid "Python"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:256
msgid "Obviously, every ``PythonPackage`` needs Python at build-time to run ``python setup.py build && python setup.py install``. Python is also needed at run-time if you want to import the module. Due to backwards incompatible changes between Python 2 and 3, it is very important to specify which versions of Python are supported. If the documentation mentions that Python 3 is required, this can be specified as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:268
msgid "If Python 2 is required, this would look like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:275
msgid "If Python 2.7 is the only version that works, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:282
msgid "The documentation may not always specify supported Python versions. Another place to check is in the ``setup.py`` file. Look for a line containing ``python_requires``. An example from `py-numpy <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-numpy/package.py>`_ looks like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:293
msgid "More commonly, you will find a version check at the top of the file:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:301
msgid "This can be converted to Spack's spec notation like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:310
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:466
msgid "setuptools"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:312
msgid "Originally, the Python language had a single build system called distutils, which is built into Python. Distutils provided a common framework for package authors to describe their project and how it should be built. However, distutils was not without limitations. Most notably, there was no way to list a project's dependencies with distutils. Along came setuptools, a non-builtin build system designed to overcome the limitations of distutils. Both projects use a similar API, making the transition easy while adding much needed functionality. Today, setuptools is used in around 75% of the Python packages in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:323
msgid "Since setuptools isn't built-in to Python, you need to add it as a dependency. To determine whether or not a package uses setuptools, search the file for an import statement like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:332
msgid "or:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:339
msgid "Some packages are designed to work with both setuptools and distutils, so you may find something like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:350
msgid "This uses setuptools if available, and falls back to distutils if not. In this case, you would still want to add a setuptools dependency, as it offers us more control over the installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:354
msgid "Unless specified otherwise, setuptools is usually a build-only dependency. That is, it is needed to install the software, but is not needed at run-time. This can be specified as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:365
msgid "cython"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:367
msgid "Compared to compiled languages, interpreted languages like Python can be quite a bit slower. To work around this, some Python developers rewrite computationally demanding sections of code in C, a process referred to as \"cythonizing\". In order to build these package, you need to add a build dependency on cython:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:378
msgid "Look for references to \"cython\" in the ``setup.py`` to determine whether or not this is necessary. Cython may be optional, but even then you should list it as a required dependency. Spack is designed to compile software, and is meant for HPC facilities where speed is crucial. There is no reason why someone would not want an optimized version of a library instead of the pure-Python version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:388
msgid "Python dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:390
msgid "When you install a package with ``pip``, it reads the ``setup.py`` file in order to determine the dependencies of the package. If the dependencies are not yet installed, ``pip`` downloads them and installs them for you. This may sound convenient, but Spack cannot rely on this behavior for two reasons:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:396
msgid "Spack needs to be able to install packages on air-gapped networks."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:398
msgid "If there is no internet connection, ``pip`` can't download the package dependencies. By explicitly listing every dependency in the ``package.py``, Spack knows what to download ahead of time."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:402
msgid "Duplicate installations of the same dependency may occur."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:404
msgid "Spack supports *activation* of Python extensions, which involves symlinking the package installation prefix to the Python installation prefix. If your package is missing a dependency, that dependency will be installed to the installation directory of the same package. If you try to activate the package + dependency, it may cause a problem if that package has already been activated."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:411
msgid "For these reasons, you must always explicitly list all dependencies. Although the documentation may list the package's dependencies, often the developers assume people will use ``pip`` and won't have to worry about it. Always check the ``setup.py`` to find the true dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:417
msgid "If the package relies on ``distutils``, it may not explicitly list its dependencies. Check for statements like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:428
msgid "Obviously, this means that ``py-numpy`` is a dependency."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:430
msgid "If the package uses ``setuptools``, check for the following clues:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:432
msgid "``install_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:434
msgid "These packages are required for installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:436
msgid "``extra_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:438
msgid "These packages are optional dependencies that enable additional functionality. You should add a variant that optionally adds these dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:442
msgid "``test_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:444
msgid "These are packages that are required to run the unit tests for the package. These dependencies can be specified using the ``type='test'`` dependency type."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:448
msgid "In the root directory of the package, you may notice a ``requirements.txt`` file. It may look like this file contains a list of all of the package's dependencies. Don't be fooled. This file is used by tools like Travis to install the pre-requisites for the package... and a whole bunch of other things. It often contains dependencies only needed for unit tests, like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:455
msgid "mock"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:456
msgid "nose"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:457
msgid "pytest"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:459
msgid "It can also contain dependencies for building the documentation, like sphinx. If you can't find any information about the package's dependencies, you can take a look in ``requirements.txt``, but be sure not to add test or documentation dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:468
msgid "Setuptools is a bit of a special case. If a package requires setuptools at run-time, how do they express this? They could add it to ``install_requires``, but setuptools is imported long before this and needed to read this line. And since you can't install the package without setuptools, the developers assume that setuptools will already be there, so they never mention when it is required. We don't want to add run-time dependencies if they aren't needed, so you need to determine whether or not setuptools is needed. Grep the installation directory for any files containing a reference to ``setuptools`` or ``pkg_resources``. Both modules come from ``py-setuptools``. ``pkg_resources`` is particularly common in scripts in ``prefix/bin``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:482
msgid "Passing arguments to setup.py"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:484
msgid "The default build and install phases should be sufficient to install most packages. However, you may want to pass additional flags to either phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:488
msgid "You can view the available options for a particular phase with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:495
msgid "Each phase provides a ``<phase_args>`` function that can be used to pass arguments to that phase. For example, `py-numpy <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-numpy/package.py>`_ adds:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:520
msgid "``PythonPackage`` provides a couple of options for testing packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:524
msgid "Import tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:526
msgid "Just because a package successfully built does not mean that it built correctly. The most reliable test of whether or not the package was correctly installed is to attempt to import all of the modules that get installed. To get a list of modules, run the following command in the source directory:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:540
msgid "Large, complex packages like ``numpy`` will return a long list of packages, while other packages like ``six`` will return an empty list. ``py-six`` installs a single ``six.py`` file. In Python packaging lingo, a \"package\" is a directory containing files like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:552
msgid "whereas a \"module\" is a single Python file. Since ``find_packages`` only returns packages, you'll have to determine the correct module names yourself. You can now add these packages and modules to the package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:562
msgid "When you run ``spack install --test=root py-six``, Spack will attempt to import the ``six`` module after installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:565
msgid "These tests most often catch missing dependencies and non-RPATHed libraries. Make sure not to add modules/packages containing the word \"test\", as these likely won't end up in installation directory."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:571
msgid "Unit tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:573
msgid "The package you want to install may come with additional unit tests. By default, Spack runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:581
msgid "if it detects that the ``setup.py`` file supports a ``test`` phase. You can add additional build-time or install-time tests by overriding ``test`` and ``installtest``, respectively. For example, ``py-numpy`` adds:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:595
msgid "Setup file in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:597
msgid "In order to be compatible with package managers like ``pip``, the package is required to place its ``setup.py`` in the root of the tarball. However, not every Python package cares about ``pip`` or PyPI. If you are installing a package that is not hosted on PyPI, you may find that it places its ``setup.py`` in a sub-directory. To handle this, add the directory containing ``setup.py`` to the package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:611
msgid "Alternate names for setup.py"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:613
msgid "As previously mentioned, packages need to call their setup script ``setup.py`` in order to be compatible with package managers like ``pip``. However, some packages like `py-meep <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-meep/package.py>`_  and `py-adios <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-adios/package.py>`_ come with multiple setup scripts, one for a serial build and another for a parallel build. You can override the default name to use like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:629
msgid "PythonPackage vs. packages that use Python"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:631
msgid "There are many packages that make use of Python, but packages that depend on Python are not necessarily ``PythonPackages``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:636
msgid "Choosing a build system"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:638
msgid "First of all, you need to select a build system. ``spack create`` usually does this for you, but if for whatever reason you need to do this manually, choose ``PythonPackage`` if and only if the package contains a ``setup.py`` file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:645
msgid "Choosing a package name"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:647
msgid "Selecting the appropriate package name is a little more complicated than choosing the build system. By default, ``spack create`` will prepend ``py-`` to the beginning of the package name if it detects that the package uses the ``PythonPackage`` build system. However, there are occasionally packages that use ``PythonPackage`` that shouldn't start with ``py-``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:654
msgid "busco"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:655
msgid "easybuild"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:656
msgid "httpie"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:657
msgid "mercurial"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:658
msgid "scons"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:659
msgid "snakemake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:661
msgid "The thing these packages have in common is that they are command-line tools that just so happen to be written in Python. Someone who wants to install ``mercurial`` with Spack isn't going to realize that it is written in Python, and they certainly aren't going to assume the package is called ``py-mercurial``. For this reason, we manually renamed the package to ``mercurial``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:668
msgid "Likewise, there are occasionally packages that don't use the ``PythonPackage`` build system but should still be prepended with ``py-``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:672
msgid "py-genders"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:673
msgid "py-py2cairo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:674
msgid "py-pygobject"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:675
msgid "py-pygtk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:676
msgid "py-pyqt"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:677
msgid "py-pyserial"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:678
msgid "py-sip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:679
msgid "py-xpyb"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:681
msgid "These packages are primarily used as Python libraries, not as command-line tools. You may see C/C++ packages that have optional Python language-bindings, such as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:685
msgid "antlr"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:686
msgid "cantera"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:687
msgid "conduit"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:688
msgid "pagmo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:689
msgid "vtk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:691
msgid "Don't prepend these kind of packages with ``py-``. When in doubt, think about how this package will be used. Is it primarily a Python library that will be imported in other Python scripts? Or is it a command-line tool, or C/C++/Fortran program with optional Python modules? The former should be prepended with ``py-``, while the latter should not."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:700
msgid "extends vs. depends_on"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:702
msgid "This is very similar to the naming dilemma above, with a slight twist. As mentioned in the :ref:`Packaging Guide <packaging_extensions>`, ``extends`` and ``depends_on`` are very similar, but ``extends`` adds the ability to *activate* the package. Activation involves symlinking everything in the installation prefix of the package to the installation prefix of Python. This allows the user to import a Python module without having to add that module to ``PYTHONPATH``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:710
msgid "When deciding between ``extends`` and ``depends_on``, the best rule of thumb is to check the installation prefix. If Python libraries are installed to ``prefix/lib/python2.7/site-packages`` (where 2.7 is the MAJOR.MINOR version of Python you used to install the package), then you should use ``extends``. If Python libraries are installed elsewhere or the only files that get installed reside in ``prefix/bin``, then don't use ``extends``, as symlinking the package wouldn't be useful."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:722
msgid "PyPI has hundreds of thousands of packages that are not yet in Spack, and ``pip`` may be a perfectly valid alternative to using Spack. The main advantage of Spack over ``pip`` is its ability to compile non-Python dependencies. It can also build cythonized versions of a package or link to an optimized BLAS/LAPACK library like MKL, resulting in calculations that run orders of magnitude faster. Spack does not offer a significant advantage to other python-management systems for installing and using tools like flake8 and sphinx. But if you need packages with non-Python dependencies like numpy and scipy, Spack will be very valuable to you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:733
msgid "Anaconda is another great alternative to Spack, and comes with its own ``conda`` package manager. Like Spack, Anaconda is capable of compiling non-Python dependencies. Anaconda contains many Python packages that are not yet in Spack, and Spack contains many Python packages that are not yet in Anaconda. The main advantage of Spack over Anaconda is its ability to choose a specific compiler and BLAS/LAPACK or MPI library. Spack also has better platform support for supercomputers. On the other hand, Anaconda offers Windows support."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:746
msgid "For more information on Python packaging, see: https://packaging.python.org/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:10
msgid "QMakePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:12
msgid "Much like Autotools and CMake, QMake is a build-script generator designed by the developers of Qt. In its simplest form, Spack's ``QMakePackage`` runs the following steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:24
msgid "QMake does not appear to have a standardized way of specifying the installation directory, so you may have to set environment variables or edit ``*.pro`` files to get things working properly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:32
msgid "The ``QMakePackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:34
msgid "``qmake`` - generate Makefiles"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:47
msgid "Any of these phases can be overridden in your package as necessary. There is also a ``check`` method that looks for a ``check`` target in the Makefile. If a ``check`` target exists and the user runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:56
msgid "Spack will run ``make check`` after the build phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:62
msgid "Packages that use the QMake build system can be identified by the presence of a ``<project-name>.pro`` file. This file declares things like build instructions and dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:66
msgid "One thing to look for is the ``minQtVersion`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:73
msgid "This means that Qt 5.6.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:80
msgid "At the bare minimum, packages that use the QMake build system need a ``qt`` dependency. Since this is always the case, the ``QMakePackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:89
msgid "If you want to specify a particular version requirement, or need to link to the ``qt`` libraries, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:98
msgid "Passing arguments to qmake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:100
msgid "If you need to pass any arguments to the ``qmake`` call, you can override the ``qmake_args`` method like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:115
msgid "For more information on the QMake build system, see: http://doc.qt.io/qt-5/qmake-manual.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:10
msgid "RPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:12
msgid "Like Python, R has its own built-in build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:14
msgid "The R build system is remarkably uniform and well-tested. This makes it one of the easiest build systems to create new Spack packages for."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:22
msgid "The ``RPackage`` base class has a single phase:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:35
msgid "Finding R packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:37
msgid "The vast majority of R packages are hosted on CRAN - The Comprehensive R Archive Network. If you are looking for a particular R package, search for \"CRAN <package-name>\" and you should quickly find what you want. If it isn't on CRAN, try Bioconductor, another common R repository."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:42
msgid "For the purposes of this tutorial, we will be walking through `r-caret <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-caret/package.py>`_ as an example. If you search for \"CRAN caret\", you will quickly find what you are looking for at https://cran.r-project.org/web/packages/caret/index.html. If you search for \"Package source\", you will find the download URL for the latest release. Use this URL with ``spack create`` to create a new package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:54
msgid "The first thing you'll notice is that Spack prepends ``r-`` to the front of the package name. This is how Spack separates R package extensions from the rest of the packages in Spack. Without this, we would end up with package name collisions more frequently than we would like. For instance, there are already packages for both:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:60
msgid "``ape`` and ``r-ape``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:61
msgid "``curl`` and ``r-curl``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:62
msgid "``gmp`` and ``r-gmp``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:63
msgid "``jpeg`` and ``r-jpeg``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:64
msgid "``openssl`` and ``r-openssl``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:65
msgid "``uuid`` and ``r-uuid``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:66
msgid "``xts`` and ``r-xts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:68
msgid "Many popular programs written in C/C++ are later ported to R as a separate project."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:75
msgid "The first thing you'll need to add to your new package is a description. The top of the homepage for ``caret`` lists the following description:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:78
msgid "caret: Classification and Regression Training"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:80
msgid "Misc functions for training and plotting classification and regression models."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:82
msgid "You can either use the short description (first line), long description (second line), or both depending on what you feel is most appropriate."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:89
msgid "If you look at the bottom of the page, you'll see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:91
msgid "Linking:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:93
msgid "Please use the canonical form https://CRAN.R-project.org/package=caret to link to this page."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:95
msgid "Please uphold the wishes of the CRAN admins and use https://CRAN.R-project.org/package=caret as the homepage instead of https://cran.r-project.org/web/packages/caret/index.html. The latter may change without notice."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:104
msgid "As previously mentioned, the download URL for the latest release can be found by searching \"Package source\" on the homepage."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:109
msgid "List URL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:111
msgid "CRAN maintains a single webpage containing the latest release of every single package: https://cran.r-project.org/src/contrib/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:114
msgid "Of course, as soon as a new release comes out, the version you were using in your package is no longer available at that URL. It is moved to an archive directory. If you search for \"Old sources\", you will find: https://cran.r-project.org/src/contrib/Archive/caret"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:119
msgid "If you only specify the URL for the latest release, your package will no longer be able to fetch that version as soon as a new release comes out. To get around this, add the archive directory as a ``list_url``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:127
msgid "As an extension of the R ecosystem, your package will obviously depend on R to build and run. Normally, we would use ``depends_on`` to express this, but for R packages, we use ``extends``. ``extends`` is similar to ``depends_on``, but adds an additional feature: the ability to \"activate\" the package by symlinking it to the R installation directory. Since every R package needs this, the ``RPackage`` base class contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:140
msgid "Take a close look at the homepage for ``caret``. If you look at the \"Depends\" section, you'll notice that ``caret`` depends on \"R (≥ 2.10)\". You should add this to your package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:151
msgid "R dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:153
msgid "R packages are often small and follow the classic Unix philosophy of doing one thing well. They are modular and usually depend on several other packages. You may find a single package with over a hundred dependencies. Luckily, CRAN packages are well-documented and list all of their dependencies in the following sections:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:159
msgid "Depends"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:160
msgid "Imports"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:161
msgid "LinkingTo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:163
msgid "As far as Spack is concerned, all 3 of these dependency types correspond to ``type=('build', 'run')``, so you don't have to worry about them. If you are curious what they mean, https://github.com/spack/spack/issues/2951 has a pretty good summary:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:168
msgid "``Depends`` is required and will cause those R packages to be *attached*, that is, their APIs are exposed to the user. ``Imports`` *loads* packages so that *the package* importing these packages can access their APIs, while *not* being exposed to the user. When a user calls ``library(foo)`` s/he *attaches* package ``foo`` and all of the packages under ``Depends``. Any function in one of these package can be called directly as ``bar()``. If there are conflicts, user can also specify ``pkgA::bar()`` and ``pkgB::bar()`` to distinguish between them. Historically, there was only ``Depends`` and ``Suggests``, hence the confusing names. Today, maybe ``Depends`` would have been named ``Attaches``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:179
msgid "The ``LinkingTo`` is not perfect and there was recently an extensive discussion about API/ABI among other things on the R-devel mailing list among very skilled R developers:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:183
msgid "https://stat.ethz.ch/pipermail/r-devel/2016-December/073505.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:184
msgid "https://stat.ethz.ch/pipermail/r-devel/2017-January/073647.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:186
msgid "Some packages also have a fourth section:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:188
msgid "Suggests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:190
msgid "These are optional, rarely-used dependencies that a user might find useful. You should **NOT** add these dependencies to your package. R packages already have enough dependencies as it is, and adding optional dependencies can really slow down the concretization process. They can also introduce circular dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:198
msgid "Core, recommended, and non-core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:200
msgid "If you look at \"Depends\", \"Imports\", and \"LinkingTo\", you will notice 3 different types of packages:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:205
msgid "Core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:207
msgid "If you look at the ``caret`` homepage, you'll notice a few dependencies that don't have a link to the package, like ``methods``, ``stats``, and ``utils``. These packages are part of the core R distribution and are tied to the R version installed. You can basically consider these to be \"R itself\". These are so essential to R so it would not make sense that they could be updated via CRAN. If so, you would basically get a different version of R. Thus, they're updated when R is updated."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:215
msgid "You can find a list of these core libraries at: https://github.com/wch/r-source/tree/trunk/src/library"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:220
msgid "Recommended packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:222
msgid "When you install R, there is an option called ``--with-recommended-packages``. This flag causes the R installation to include a few \"Recommended\" packages (legacy term). They are for historical reasons quite tied to the core R distribution, developed by the R core team or people closely related to it. The R core distribution \"knows\" about these package, but they are indeed distributed via CRAN. Because they're distributed via CRAN, they can also be updated between R version releases."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:230
msgid "Spack explicitly adds the ``--without-recommended-packages`` flag to prevent the installation of these packages. Due to the way Spack handles package activation (symlinking packages to the R installation directory), pre-existing recommended packages will cause conflicts for already-existing files. We could either not include these recommended packages in Spack and require them to be installed through ``--with-recommended-packages``, or we could not install them with R and let users choose the version of the package they want to install. We chose the latter."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:239
msgid "Since these packages are so commonly distributed with the R system, many developers may assume these packages exist and fail to list them as dependencies. Watch out for this."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:243
msgid "You can find a list of these recommended packages at: https://github.com/wch/r-source/blob/trunk/share/make/vars.mk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:248
msgid "Non-core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:250
msgid "These are packages that are neither \"core\" nor \"recommended\". There are more than 10,000 of these packages hosted on CRAN alone."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:253
msgid "For each of these package types, if you see that a specific version is required, for example, \"lattice (≥ 0.20)\", please add this information to the dependency:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:264
msgid "Non-R dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:266
msgid "Some packages depend on non-R libraries for linking. Check out the `r-stringi <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-stringi/package.py>`_ package for an example: https://CRAN.R-project.org/package=stringi. If you search for the text \"SystemRequirements\", you will see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:271
msgid "ICU4C (>= 52, optional)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:273
msgid "This is how non-R dependencies are listed. Make sure to add these dependencies. The default dependency type should suffice."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:278
msgid "Passing arguments to the installation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:280
msgid "Some R packages provide additional flags that can be passed to ``R CMD INSTALL``, often to locate non-R dependencies. `r-rmpi <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-rmpi/package.py>`_ is an example of this, and flags for linking to an MPI library. To pass these to the installation command, you can override ``configure_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:307
msgid "There is a similar ``configure_vars`` function that can be overridden to pass variables to the build."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:314
msgid "CRAN hosts over 10,000 R packages, most of which are not in Spack. Many users may not need the advanced features of Spack, and may prefer to install R packages the normal way:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:324
msgid "R will search CRAN for the ``ggplot2`` package and install all necessary dependencies for you. If you want to update all installed R packages to the latest release, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:333
msgid "This works great for users who have internet access, but those on an air-gapped cluster will find it easier to let Spack build a download mirror and install these packages for you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:337
msgid "Where Spack really shines is its ability to install non-R dependencies and link to them properly, something the R installation mechanism cannot handle."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:345
msgid "For more information on installing R packages, see: https://stat.ethz.ch/R-manual/R-devel/library/utils/html/INSTALL.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:10
msgid "RubyPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:12
msgid "Like Perl, Python, and R, Ruby has its own build system for installing Ruby gems."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:15
msgid "This build system is a work-in-progress. See https://github.com/spack/spack/pull/3127 for more information."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:10
msgid "SConsPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:12
msgid "SCons is a general-purpose build system that does not rely on Makefiles to build software. SCons is written in Python, and handles all building and linking itself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:16
msgid "As far as build systems go, SCons is very non-uniform. It provides a common framework for developers to write build scripts, but the build scripts themselves can vary drastically. Some developers add subcommands like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:29
msgid "Others don't add any subcommands. Some have configuration options that can be specified through variables on the command line. Others don't."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:36
msgid "As previously mentioned, SCons allows developers to add subcommands like ``build`` and ``install``, but by default, installation usually looks like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:45
msgid "To facilitate this, the ``SConsPackage`` base class provides the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:51
msgid "Package developers often add unit tests that can be invoked with ``scons test`` or ``scons check``. Spack provides a ``test`` method to handle this. Since we don't know which one the package developer chose, the ``test`` method does nothing by default, but can be easily overridden like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:67
msgid "SCons packages can be identified by their ``SConstruct`` files. These files handle everything from setting up subcommands and command-line options to linking and compiling."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:71
msgid "One thing to look for is the ``EnsureSConsVersion`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:78
msgid "This means that SCons 2.3.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:85
msgid "At the bare minimum, packages that use the SCons build system need a ``scons`` dependency. Since this is always the case, the ``SConsPackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:94
msgid "If you want to specify a particular version requirement, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:104
msgid "Finding available options"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:106
msgid "The first place to start when looking for a list of valid options to build a package is ``scons --help``. Some packages like `kahip <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/kahip/package.py>`_ don't bother overwriting the default SCons help message, so this isn't very useful, but other packages like `serf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/serf/package.py>`_ print a list of valid command-line variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:180
msgid "More advanced packages like `cantera <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cantera/package.py>`_ use ``scons --help`` to print a list of subcommands:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:227
msgid "You'll notice that cantera provides a ``scons help`` subcommand. Running ``scons help`` prints a list of valid command-line variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:232
msgid "Passing arguments to scons"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:234
msgid "Now that you know what arguments the project accepts, you can add them to the package build phase. This is done by overriding ``build_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:253
msgid "``SConsPackage`` also provides an ``install_args`` function that you can override to pass additional arguments to ``scons install``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:258
msgid "Compiler wrappers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:260
msgid "By default, SCons builds all packages in a separate execution environment, and doesn't pass any environment variables from the user environment. Even changes to ``PATH`` are not propagated unless the package developer does so."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:265
msgid "This is particularly troublesome for Spack's compiler wrappers, which depend on environment variables to manage dependencies and linking flags. In many cases, SCons packages are not compatible with Spack's compiler wrappers, and linking must be done manually."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:270
msgid "First of all, check the list of valid options for anything relating to environment variables. For example, cantera has the following option:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:282
msgid "In the case of cantera, using ``env_vars=all`` allows us to use Spack's compiler wrappers. If you don't see an option related to environment variables, try using Spack's compiler wrappers by passing ``spack_cc``, ``spack_cxx``, and ``spack_fc`` via the ``CC``, ``CXX``, and ``FC`` arguments, respectively. If you pass them to the build and you see an error message like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:294
msgid "you'll know that the package isn't compatible with Spack's compiler wrappers. In this case, you'll have to use the path to the actual compilers, which are stored in ``self.compiler.cc`` and friends. Note that this may involve passing additional flags to the build to locate dependencies, a task normally done by the compiler wrappers. serf is an example of a package with this limitation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:305
msgid "For more information on the SCons build system, see: http://scons.org/documentation.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:10
msgid "WafPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:12
msgid "Like SCons, Waf is a general-purpose build system that does not rely on Makefiles to build software."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:19
msgid "The ``WafPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:21
msgid "``configure`` - configure the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:34
msgid "Each of these are standard Waf commands and can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:41
msgid "Each phase provides a ``<phase>`` function that runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:48
msgid "where ``<jobs>`` is the number of parallel jobs to build with. Each phase also has a ``<phase_args>`` function that can pass arguments to this call. All of these functions are empty except for the ``configure_args`` function, which passes ``--prefix=/path/to/installation/prefix``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:57
msgid "``WafPackage`` also provides ``test`` and ``installtest`` methods, which are run after the ``build`` and ``install`` phases, respectively. By default, these phases do nothing, but you can override them to run package-specific unit tests. For example, the `py-py2cairo <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-py2cairo/package.py>`_ package uses:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:76
msgid "Each Waf package comes with a custom ``waf`` build script, written in Python. This script contains instructions to build the project."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:79
msgid "The package also comes with a ``wscript`` file. This file is used to override the default ``configure``, ``build``, and ``install`` phases to customize the Waf project. It also allows developers to override the default ``./waf --help`` message. Check this file to find useful information about dependencies and the minimum versions that are supported."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:90
msgid "``WafPackage`` does not require ``waf`` to build. ``waf`` is only needed to create the ``./waf`` script. Since ``./waf`` is a Python script, Python is needed to build the project. ``WafPackage`` adds the following dependency automatically:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:100
msgid "Waf only supports Python 2.5 and up."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:104
msgid "Passing arguments to waf"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:106
msgid "As previously mentioned, each phase comes with a ``<phase_args>`` function that can be used to pass arguments to that particular phase. For example, if you need to pass arguments to the build phase, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:122
msgid "A list of valid options can be found by running ``./waf --help``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:128
msgid "For more information on the Waf build system, see: https://waf.io/book/"
msgstr ""

